#!/bin/bash
# =========================================================================
# =========================================================================
#
#	debian-deb-start
#	  Creates a new container, if needed, then starts it.
#
# =========================================================================
#
# @author Jay Wheeler.
# @version 0.0.4
# @copyright © 2018. EarthWalk Software.
# @license Licensed under the GNU General Public License, GPL-3.0-or-later.
# @package ewsdocker/debian-base
# @subpackage debian-deb-start
#
# =========================================================================
#
#	Copyright © 2018. EarthWalk Software
#	Licensed under the GNU General Public License, GPL-3.0-or-later.
#
#   This file is part of ewsdocker/debian-docker-start.
#
#   ewsdocker/debian-docker-start is free software: you can redistribute 
#   it and/or modify it under the terms of the GNU General Public License 
#   as published by the Free Software Foundation, either version 3 of the 
#   License, or (at your option) any later version.
#
#   ewsdocker/debian-docker-start is distributed in the hope that it will 
#   be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
#   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ewsdocker/debian-docker-start.  If not, see 
#   <http://www.gnu.org/licenses/>.
#
# =========================================================================
# =========================================================================
#
#	A simple state machine based on stately binary functions.  Each function
#		- processes a single state and 
#		- returns a binary result (0 = true, 1 = false)
#
#	The state machine engine then selects the next state based on the
#	returned result of the current state, and moves on to process the
#	next state.
#
# =========================================================================
#
#	state	function		true	false
#	-----	---------------	----	-----
#
#	  0		initProcessor	  1		  7
#	  1		getContainer	  3		  2
#	  2		runContainer	  5		  7
#	  3		checkRunning	  6		  4
#	  4		startContainer	  5		  7
#	  5		waitEvent		  6		  7
#	  6		(exit - normal)	  -		  -
#	  7		(exit - error)	  -		  -
#
# =========================================================================
# =========================================================================
#
#	Runs in docker host system, NOT in the container!
#
# =========================================================================

declare    container_name=""
declare    container_status=""

declare -a container_fields=()
declare -a cliBuffer=( "${@}" )

# =========================================================================================
#
#	State Errors
#
# =========================================================================================
declare    error_none=0
declare    error_state=1
declare    error_template=2
declare    error_unknown=3
declare    error_container=4
declare    error_run=5
declare    error_start=6
declare    error_status=7
declare    error_check=8
declare    error_running=9
declare    error_exited=10
declare    error_event=11

# =========================================================================================
#
#	Wait Events
#
# =========================================================================================
declare    event_running=0
declare    event_exiting=1

# =========================================================================================
# =========================================================================================
#
# The following block must remain in the same order, 
#   and must appear prior to any function declarations.
#
# =========================================================================================
# =========================================================================================

[[ ${#cliBuffer} -eq 0 ]] && 
 {
	container_error=${error_template}

    echo "Missing container name"
    exit ${container_error}
 }

container_name="${cliBuffer[0]}"

# =========================================================================================

declare -a names

OIFS="$IFS"
IFS=":"
    read -a names <<< "${cliBuffer[0]}"
IFS="$OIFS"

[[ ${#names[@]} -eq 2 ]] && container_image="${names[0]}-${names[1]}" || container_image="${names[0]}-latest"

source ${HOME}/.config/docker/${container_image}/lms-base.conf

# =========================================================================================

LMS_BIN="${LMS_BASE}/bin"
LMS_LIB="${LMS_BASE}/lib/lms"
LMS_SHARE="${LMS_BASE}/share/lms"

# =========================================================================================
# =========================================================================================

source ${LMS_LIB}/lmsconDisplay-0.0.1.bash

lmscli_optQuiet=${LMSOPT_QUIET}

# =========================================================================================
# =========================================================================================

# =========================================================================================
#
#   checkUserdef
#
#  		Check whether or not the container is in an exited state.
#
#   parameters:
#      $pStatus = (string) Status to check for (refer to docker ps)
#      $pSearch = (string) Value to search for in $container_status
#
#	returns:
#      0 = exited
#      1 = not exited
#
# =========================================================================================
function checkUserdef()
{
    checkStatus "${pStatus}" "${pSearch}"
	[[ $? -eq 0 ]] &&
	 {
		lmsconDisplay "checkUserdef : true"
    	return 0
 	 }

	container_error=${error_exited}	 

	lmsconDisplay "checkUserdef : false"
	return 1
}

# =========================================================================================
# =========================================================================================

# =========================================================================================
#
#	getContainer
#
#		get the requested container information
#
#	parameters:
#		none
#
#    Result:
#        0 = found container information
#        1 = no container found
#
# =========================================================================================
function getContainer()
{
	local -a aStatus=()

	local    oifs=$IFS
	IFS=$'\n' 

		read -rd '' -a aStatus <<<"$(docker container ls -a --filter name=${container_image} )"

	IFS=${oifs}

	[[ ${#aStatus[@]} -lt 2 ]] &&
	 {
		lmsconDisplay "getContainer : false"

		container_error=${error_container}
	    return 1
	 }
 
	container_status=${aStatus[1]}

	lmsconDisplay "getContainer : true"
    return 0
}

# =========================================================================================
#
#	getStatus
#
#		get the current status of the application
#
#	parameters:
#
#		filters = string to explode
#    Result:
#        0 = no error
#        non-zero = error number
#
# =========================================================================================
function getStatus()
{
	local status="${1}"
	local -a aStatus=()

	local    oifs=$IFS
	IFS=$'\n' read -rd '' -a aStatus <<<"$(docker container ls -a  --filter name=${container_name}  --filter status=${status} )"
	IFS=${oifs}

	[[ ${#aStatus[@]} -lt 2 ]] &&
	 {
		lmsconDisplay "getStatus : false"

		container_error=${error_status}
	    return 1
	 }
 
	container_status=${aStatus[1]}

	lmsconDisplay "getStatus : true"
	
	return 0
}

# =========================================================================================
#
#   checkStatus
#
#  		Check the requested status and the search string present
#
#   parameters:
#      $pStatus = (string) Status to check for (refer to docker ps)
#      $pSearch = (string) Value to search for in $container_status
#
#	returns:
#      0 = status matched and search value was found
#      1 = search string did not match
#	   2 = 'docker container ls' failed
#
# =========================================================================================
function checkStatus()
{
    local pStatus="${1}"
    local pSearch="${2}"

	getStatus "${pStatus}"
	[[ $? -eq 0 ]] &&
	 {
		lmsconDisplay "checkStatus : true"
		[[ -z "${pSearch}" ]] && return 0

		if echo "${container_status}" | grep -q "${pSearch}" ; then	return 0 ; fi
	 }

	lmsconDisplay "checkStatus : false"
	container_error=${error_check}
	return 1
}

# =========================================================================================
#
#   runContainer
#
#  		Run a container.
#
#   parameters:
#		None
#
#	returns:
#      0 = running
#      1 = not running
#
# =========================================================================================
function runContainer()
{
	${LMS_BIN}/${container_name} & > /dev/null 2>&1
	[[ $? -eq 0 ]] && 
	 {
		sleep "3s"
		disown

		lmsconDisplay "runContainer : true"
		return 0
	 }

	lmsconDisplay "runContainer : false"

	container_error=${error_run}
    return 1
}

# =========================================================================================
#
#   startContainer
#
#  		Start an exited (not running) container.
#
#   parameters:
#		None
#
#	returns:
#      0 = started
#      1 = not started
#
# =========================================================================================
function startContainer()
{
    docker start ${container_image}
    [[ $? -eq 0 ]] && 
     {
	    lmsconDisplay "startContainer : true"
        return 0
     }

	container_error=${error_start}

    lmsconDisplay "startContainer : false"
    return 1
}

# =========================================================================================
#
#   checkRunning
#
#  		Check whether or not the container is a running state.
#
#   parameters:
#		None
#
#	returns:
#      0 = running
#      1 = not running
#
# =========================================================================================
function checkRunning()
{
	checkStatus "running" "Up"
	[[ $? -eq 0 ]] &&
	 {
		lmsconDisplay "checkRunning : true."
    	return 0
 	 }

	container_error=${error_running}

	lmsconDisplay "checkRunning: false."
	return 1
}

# =========================================================================================
#
#   checkExited
#
#  		Check whether or not the container is in an exited state.
#
#   parameters:
#		None
#
#	returns:
#      0 = exited
#      1 = not exited
#
# =========================================================================================
function checkExited()
{
    checkStatus "exited" "Exited"
	[[ $? -eq 0 ]] &&
	 {
		lmsconDisplay "checkExited: true"
    	return 0
 	 }

	container_error=${error_exited}	 

	lmsconDisplay "checkExited: false"
	return 1
}

# *****************************************************************************
#
#   waitEvent
#
#		wait for $event to be true, or $timeout expires
#
#	parameters:
#		event = event number
#		timeout = number of seconds to wait
#
#	returns:
#		0 = running
#		1 = not running
#
# *****************************************************************************
function waitEvent()
{
	local event=${1:-"${event_running}"}
	local timeout=${2:-"$LMSOPT_TIMEOUT"}

	local interval="1s"
	local lResult=0

	while [[ ${timeout} -gt 0 ]]
	do

		sleep ${interval}

		case ${event} in 

			${event_running} )

				checkRunning
				lResult=$?
				;;

			${event_exiting} )

				checkExited
				lResult=$?
				;;

			${event_userdef} )

				checkUserdef
				lResult=$?
				;;

			*)	break

		esac

		[[ ${lResult} -eq 0 ]] && 
		 {
			lmsconDisplay "waitEvent: true"
		    return 0
		 }

		let timeout=timeout-1
	done

	container_error=${error_event}

	lmsconDisplay "waitEvent: false"
	return 1
}

# =========================================================================================
#
#   initProcessor
#
#  		Initialize the state processor variables and
#		  validate the container.
#
#   parameters:
#		None
#
#	returns:
#      0 = no error
#      non-zero = error code
#
# =========================================================================================
function initProcessor()
{
	if [ -e "${LMS_BIN}/${container_name}" ]
	then
		lmsconDisplay "initProcessor : true"
		return 0
	fi

	container_error=${error_unknown}

	lmsconDisplay "initProcessor : false"
	return 1
}

# =========================================================================================
#
#   execContainer
#
#   	returns 0 if able to start, error code if not
#
#   parameters:
#		None
#
#	returns:
#      	0 = no error
#      	non-zero = error code
#
# =========================================================================================
function execContainer()
{
	local container_state=0
	local container_next=0

	container_error=${error_none}

	while [ true ]
	do

		case ${container_state} in
		
			0)	initProcessor
				[[ $? -eq 0 ]] && container_next=1 || container_next=7

				;;

			1)	getContainer
				[[ $? -eq 0 ]] && container_next=3 || container_next=2

				;;

			2)	runContainer
				[[ $? -eq 0 ]] && container_next=5 || container_next=7

				;;

			3)	checkRunning
				[[ $? -eq 0 ]] && container_next=6 || container_next=4

				;;

			4)	startContainer
				[[ $? -eq 0 ]] && container_next=5 || container_next=7

				;;

			5)	waitEvent $event_running 30
				[[ $? -eq 0 ]] && container_next=6 || container_next=7

				;;

			6)	container_error=${error_none}
				container_next=98

				break

				;;

			7)	container_next=99

				break

				;;

			*)	container_error=${error_state}
				break

				;;

		esac

		container_state=${container_next}

	done

	return ${container_error}
}
	
# =========================================================================================
# =========================================================================================
#
#		Start Application Here
#
# =========================================================================================
# =========================================================================================

execContainer
[[ $? -eq 0 ]] && lmsconDisplay "Started \"${container_name}\"" || lmsconDisplay "Unable to start \"${container_name}\"" 

exit ${container_error}
